02-线性结构2 一元多项式的乘法与加法运算 (20分)
设计函数分别求两个一元多项式的乘积与和。

输入格式:
输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。

输出格式:
输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。

输入样例:
4 3 4 -5 2  6 1  -2 0
3 5 20  -7 4  3 1
输出样例:
15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1
5 20 -4 4 -5 2 9 1 -2 0
```c++
#include<iostream>
#include <stdio.h>
#include <stdlib.h>

using namespace std;

typedef struct PolyNode
{
	int coef;            //系数
	int exp;			   //指数
	struct PolyNode *next;
}PolyNode;
typedef PolyNode *Polynomial;
 
 //创建多项式链表  
Polynomial CreateList() {
	int co;   //系数
	int ex;     //指数
	Polynomial p,L,s; 
	L = (Polynomial)malloc(sizeof(PolyNode));
	L->next=NULL;
	s=L; 
	int n;
	scanf("%d",&n);
	while(n--){
		p = (Polynomial)malloc(sizeof(PolyNode));
		scanf("%d%d",&co,&ex);	
		p->coef = co; 
		p->exp = ex; 
		p->next = NULL;
		s->next=p;
		s=p;
	} 
	s->next=NULL;
	return L; 
}

void attach(int c, int e, Polynomial rear)
{
	Polynomial p = (Polynomial)malloc(sizeof(PolyNode));
	p->coef = c;
	p->exp = e;
	p->next=NULL;
	rear->next = p;
	rear = p;
}

//显示
void Display(Polynomial p){
	Polynomial Pointer;
	Pointer = p;
	if (Pointer == NULL){
		printf("0 0");
	}
	int flag=0;
	while (Pointer != NULL){
		if(flag==0){
			printf("%d %d", Pointer->coef, Pointer->exp);
			Pointer = Pointer->next;
			flag=1;
		}
		else{
			printf(" %d %d", Pointer->coef, Pointer->exp);
			Pointer = Pointer->next;
		}
	} 
}


//多项式相乘
Polynomial LinkMult(Polynomial A, Polynomial B){
  	Polynomial front, rear, t, t1, t2;
	front =(Polynomial)malloc(sizeof(PolyNode));
	front->next = NULL;
	rear = front;
	int c, e;
	t1 = A->next; t2 = B->next;
	if (!t1 || !t2)
		return NULL;
	while (t2){
		c = t1->coef*t2->coef;
		e = t1->exp + t2->exp;
		attach(c, e, rear);
		rear=rear->next;
		t2 = t2->next;
	}
	t1 = t1->next;
	while (t1){
		t2 = B->next;
		rear = front;
		while (t2){
			c = t1->coef*t2->coef;
			e = t1->exp + t2->exp;
			while ((rear->next) && (rear->next->exp > e)){
				rear = rear->next;
			}
			if ((rear->next) && (rear->next->exp == e)){
				if ((rear->next->coef + c) != 0){
					rear->next->coef += c;
				}
				else{
					t = rear->next;
					rear->next = t->next;
					free(t);
				}
			}
			else{
				t = (Polynomial)malloc(sizeof(PolyNode));
				t->coef = c;
				t->exp = e;
				t->next = rear->next;
				rear->next = t;
				rear = rear->next; 
			}
			t2 = t2->next;
		}
		t1 = t1->next;
	}
	t = front;
	front = front->next;
	free(t);
	return front;
}

int compare(int a, int b){
	if (a > b)
		return 1;
	if (a < b)
		return 0;
	if (a == b)
		return -1; 
}  
//相加 
Polynomial LinkList(Polynomial A, Polynomial B){
	Polynomial front, rear, t,p1,p2;
	p1=A->next;
	p2=B->next; 
	front =(Polynomial)malloc(sizeof(PolyNode));
	front->next = NULL;
	rear = front;
	int sum = 0;
	if (!p1 && !p2)
		return NULL;
	while (p1&&p2){
		switch (compare(p1->exp, p2->exp)){
		case 1:
			attach(p1->coef, p1->exp, rear);
			rear=rear->next;
			p1 = p1->next;
			break;
		case 0:
			attach(p2->coef, p2->exp, rear);
			rear=rear->next;
			p2 = p2->next;
			break;
		case -1:
			sum = p1->coef + p2->coef;
			if (sum){
				attach(sum, p1->exp, rear);
				rear=rear->next;
			}
			p1 = p1->next;
			p2 = p2->next;
			break;
		}
	}
	for (; p1 != 0;attach(p1->coef, p1->exp, rear),	rear=rear->next, p1 = p1->next);
	for (; p2 != 0;attach(p2->coef, p2->exp, rear),	rear=rear->next, p2 = p2->next);
	t = front;
	front = front->next;
	free(t);
	return front;
}

int main(){
	Polynomial A, B, C,D;
	A = CreateList();
	B = CreateList();
	C=LinkMult(A,B);
	Display(C);
	printf("\n");
	D=LinkList(A,B);
	Display(D);
} 


```
